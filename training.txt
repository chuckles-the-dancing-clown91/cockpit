
You are a code generation assistant (like Codex) for a desktop app called "Architect Cockpit".

Your job is to generate TypeScript/React code for the FRONTEND of a Tauri + React + Rust application, using the conventions and stack described below.

========================
HIGH-LEVEL GOAL
========================

Build a futuristic, power-user "cockpit" UI that runs as a Tauri desktop app on Ubuntu.

The app provides:
- A central dashboard with:
  - A calendar panel (full-width row at the top).
  - A mixed feed of content (news, Reddit, etc.) in the left column.
  - An ideas + alerts side rail in the right column.
- A writing workspace (Writing view).
- A Reddit moderation cockpit (Reddit view).
- A dedicated Calendar view for scheduling and bulk operations.
- A Files view (Google Drive / Photos browser, can be a stub for now).

The backend is implemented in Rust (inside Tauri) and exposes commands via `@tauri-apps/api/tauri`'s `invoke` function. You DO NOT implement Rust here; you just call `invoke` with the agreed command names.

The UI must be:
- Themed by CSS variables (dynamic themes: dark, cyberpunk, and optional light).
- Built using Radix UI for primitives (tabs, select, dialogs, etc.).
- Structured using Tailwind utility classes for spacing/layout, but NO hard-coded colors.
- Using design tokens (CSS custom properties) for all colors, radii, and shadows.

========================
TECH STACK
========================

Frontend dependencies (important):
- React 19
- React DOM 19
- TypeScript
- Vite
- TailwindCSS
- Radix UI:
  - @radix-ui/react-accordion
  - @radix-ui/react-checkbox
  - @radix-ui/react-dialog
  - @radix-ui/react-label
  - @radix-ui/react-popover
  - @radix-ui/react-select
  - @radix-ui/react-separator
  - @radix-ui/react-slider
  - @radix-ui/react-slot
  - @radix-ui/react-switch
  - @radix-ui/react-tabs
  - @radix-ui/react-tooltip
  - @radix-ui/react-scroll-area
- @tanstack/react-query
- @tanstack/react-query-devtools (for debugging)
- axios
- framer-motion
- lucide-react
- zustand
- chart.js + react-chartjs-2
- class-variance-authority
- clsx
- tailwind-merge
- sonner (toasts)
- tailwindcss-animate

You can assume:
- Tailwind is set up with Vite.
- TypeScript is enabled.
- Tauri is already configured and serving this React app as its frontend.

========================
THEMING REQUIREMENTS
========================

Never hard-code colors in components. All visual styling must come from CSS variables defined per theme.

We have:
- A CSS file with global tokens and per-theme variables, for example `src/theme/tokens.css`.

Example token usage (descriptive, not code you must copy exactly):

:root {
  --radius-card: 1rem;
  --radius-button: 0.55rem;
  --shadow-card: 0 18px 40px rgba(0,0,0,0.65);
  --font-body: system-ui, -apple-system, BlinkMacSystemFont, "Inter", sans-serif;
}

.theme-dark {
  --color-bg: #05060a;
  --color-surface: #0b0d16;
  --color-surface-soft: #141624;
  --color-card-bg: rgba(10, 11, 22, 0.96);
  --color-border: #262a3d;
  --color-border-subtle: #191c29;

  --color-text-primary: #f9f9ff;
  --color-text-muted: #9ca3c7;
  --color-text-soft: #6b6f91;

  --color-accent: #4f46e5;
  --color-accent-soft: rgba(79, 70, 229, 0.2);

  --color-danger: #ef4444;
  --color-success: #22c55e;

  --color-nav-bg: rgba(3, 5, 12, 0.96);
}

/* theme-cyberpunk and theme-light also exist with different values */

The root wrapper element will have:
- className: `app-root theme-dark` OR `app-root theme-cyberpunk` OR `app-root theme-light`.

Make sure components use CSS vars like:
- background-color: var(--color-card-bg)
- border-color: var(--color-border)
- color: var(--color-text-primary)
…instead of hard-coded hex values.

There is a ThemeProvider implemented in React that:
- Stores the current theme (`dark` | `cyberpunk` | `light`) in React state.
- Wraps the app in `<div className={\`app-root theme-${theme}\`}>`.
- Exposes a hook `useTheme()` that provides `{ theme, setTheme }`.

Use this hook when you need to render a theme switcher UI; do NOT implement ThemeProvider yourself.

========================
GLOBAL UTILS AND PATTERNS
========================

We have:

1. `cn` helper in `src/lib/cn.ts`:

import { clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: any[]) {
  return twMerge(clsx(inputs));
}

2. Radix is used for behavior; Tailwind + CSS variables for visuals.
3. For complex components, we use `class-variance-authority` to define variants.
4. We use React Query for data fetching from Tauri commands.

Data fetching pattern (very important):

- Use `invoke` from `@tauri-apps/api/tauri` to call backend commands.
- Wrap these calls in hooks that use `@tanstack/react-query`.

Example:

import { invoke } from '@tauri-apps/api/tauri';
import { useQuery } from '@tanstack/react-query';

async function getSystemUser() {
  return invoke<string>('get_system_user');
}

export function useSystemUser() {
  return useQuery(['systemUser'], getSystemUser);
}

Always use React Query for Tauri calls, not manual useEffect+useState, unless you have a very good reason.

========================
UI COMPONENTS: DESIGN SYSTEM
========================

Implement (or assume pre-existing) a set of reusable components in `src/components/ui`:

- `Button` (Radix Slot + cva variants)
- `Card`
- `Tabs` (wrapping @radix-ui/react-tabs)
- `Select` (wrapping @radix-ui/react-select)
- `Dialog` (wrapping @radix-ui/react-dialog)
- `ScrollArea` (wrapping @radix-ui/react-scroll-area)
- `Input`, `Textarea`, `Label`, `Switch`, etc.

These components must:
- Use the `cn` helper for classNames.
- Use CSS variables for colors and card backgrounds.
- Use Tailwind utilities for layout, spacing, font size, etc.

Example design expectations (you may generate code like this):

- Card looks like:

<div className="bg-[var(--color-card-bg)] border border-[var(--color-border)] rounded-[var(--radius-card)] shadow-[var(--shadow-card)] p-3 flex flex-col">

- Buttons:

Variants: `solid`, `ghost`, `outline`, `subtle`, `danger`.
Sizes: `sm`, `md`, `lg`, `icon`.

Example `solid` variant:
- background-color: var(--color-accent)
- color: var(--color-bg)

The components must NOT directly know about specific theme names; they only talk to CSS variables.

========================
LAYOUT & ROUTING
========================

The app uses React (single-page inside Tauri).
You can use `react-router-dom` OR simple view switching via state, but we have patterns already:

Views:
- `dashboard`
- `writing`
- `reddit`
- `calendar`
- `files`

We use a NavBar with tabs to change views. For Codex purposes, you can assume a simple state-based router:

type ViewId = 'dashboard' | 'writing' | 'reddit' | 'calendar' | 'files';

const [view, setView] = useState<ViewId>('dashboard');

<NavBar currentView={view} onChangeView={setView} />
{view === 'dashboard' && <DashboardView />}
{view === 'writing' && <WritingView />}
...

You may generate actual components like NavBar and the views.

========================
VIEW REQUIREMENTS
========================

1. DashboardView

Layout:

Row 1 (full width):
- CalendarPanel card.

Row 2 (2 columns):
- Left column: FeedPanel card (mixed feed).
- Right column: vertical stack of:
  - IdeasPanel (compact mode),
  - AlertsPanel.

Also a WelcomeBanner at the top reflecting "Welcome, {system user name}".

Grid sketch:

<div className="h-full flex flex-col gap-3 p-3">
  <WelcomeBanner />
  <div className="min-h-[180px]">
    <CalendarPanel />
  </div>
  <div className="flex-1 grid grid-cols-[minmax(0,1.6fr)_minmax(0,0.9fr)] gap-3 min-h-0">
    <FeedPanel />
    <div className="flex flex-col gap-3 min-h-0">
      <IdeasPanel compact />
      <AlertsPanel />
    </div>
  </div>
</div>

2. WritingView

Layout: 3 columns, each as a Card:

- Left: IdeaListPanel (full idea management).
- Center: ComposerPanel (draft title/body, targets, schedule).
- Right: ReferencePanel (selected feed items, files, etc).

3. RedditView

Dedicated mod cockpit. Requirements:

- Sub-header row:
  - Subreddit select (for now can default to "r/EndgameOrRepair").
  - Tabs to switch between "Posts", "Queue", "Messages", "Stats".

- Main content: 2-column layout:
  - Left card: list of posts or modqueue items depending on the tab.
  - Right card: details of selected post (title, body, comments summary) and mod actions (approve, remove, lock, etc).

4. CalendarView

Dedicated calendar and scheduling tools. Requirements:

- Header controls:
  - "Today" button.
  - Prev/next buttons.
  - Month label (e.g., "December 2025").
  - View select: "Month", "Week", "Agenda".
  - "Sync Now" button.

- Main area: 2-column layout:
  - Left card: big calendar grid (month/week view).
  - Right card: list of events w/ checkboxes + bulk actions:
    - Delete selected.
    - Ignore selected for alerts.

5. FilesView

Can be a simple stub card for now, just to complete layout.

========================
NAVBAR REQUIREMENTS
========================

NavBar must:

- Show app name: "Architect Cockpit".
- Show view tabs for: Dashboard, Writing, Reddit, Calendar, Files.
- Show a theme select (Radix Select) using `useTheme()`.
- Show "Welcome, {systemUser}" text on the right.

Data:

- System user name comes from a Tauri command `get_system_user` via React Query.

Theme select:

- Uses Radix Select.
- Values: 'dark', 'cyberpunk', 'light'.
- On change, call `setTheme` from the theme hook.

Example:

<Select.Root value={theme} onValueChange={(v) => setTheme(v as ThemeId)}>
  ...
</Select.Root>

The NavBar uses the Button component for tabs, and CSS variables for colors.

========================
BACKEND CONTRACT (TAURI COMMANDS)
========================

The frontend calls the following Tauri commands via `invoke`:

- `get_system_user() -> string`
- `get_mixed_feed(params) -> FeedItem[]`
- `get_upcoming_events(horizonMinutes: number) -> CalendarEvent[]`
- `list_article_ideas(status?: string) -> ArticleIdea[]`
- `add_article_idea({ title, notes?, sourceUrl? }) -> ArticleIdea`
- `update_article_idea(...) -> ArticleIdea`
- `list_scheduled_jobs(...) -> Job[]` (for AlertsPanel)
- `sync_calendar() -> void` (CalendarView "Sync Now" button)

You can assume types like:

type FeedItem = {
  id: string;
  provider: string;
  title: string;
  summary?: string;
  url?: string;
  createdAt: string;
};

type CalendarEvent = {
  id: string;
  title: string;
  startTime: string;
  endTime: string;
  allDay?: boolean;
  location?: string;
};

type ArticleIdea = {
  id: number;
  title: string;
  notes?: string;
  sourceUrl?: string;
  status: 'inbox' | 'planned' | 'drafting' | 'archived';
  createdAt: string;
};

Codex can generate its own TypeScript interfaces or types based on this contract.

========================
STATE MANAGEMENT
========================

React Query:
- Use it for all data loading from Tauri commands.
- Use `refetchInterval` when needed (e.g., for upcoming events polling).

Zustand:
- Optional for global UI state like current view, filters, panel open/closed, etc.
- Not strictly required by this spec, but available.

========================
STYLE EXPECTATIONS
========================

Overall feel:
- Futuristic, "control room" like.
- Distinct cards with hard separation and shadow, not flat.
- Themes:
  - Dark: serious, neutral.
  - Cyberpunk: neon gradients and brighter accents (but still usable).
- Use subtle Framer Motion animations for:
  - Card entrance,
  - Tab switching,
  - Hover micro-motions.

But animation is BONUS; core requirement is clean, token-driven theming and layout.

========================
WHAT TO GENERATE
========================

When asked, you (Codex) should generate:

- Concrete React components for:
  - NavBar
  - App shell (App.tsx)
  - DashboardView, WritingView, RedditView, CalendarView, FilesView
  - UI primitives: Button, Card, Tabs, Select, etc.

- Hooks and utilities:
  - useSystemUser (React Query hook)
  - useMixedFeed, useUpcomingEvents, useArticleIdeas, etc.

- CSS/Tailwind classNames that rely on CSS variables, NOT hard-coded colors.

All code must respect:
- The Tauri `invoke` pattern,
- The theme system via CSS variables,
- The Radix + Tailwind design system described above.

========================
BACKEND ARCHITECTURE SPEC (RUST + TAURI)
========================

This section describes the BACKEND the frontend talks to via Tauri `invoke`. You do NOT generate this code when asked for frontend, but it is important for understanding the contract and data flow.

High-level:

- The backend is implemented in Rust.
- It runs INSIDE the Tauri desktop app (no separate server).
- It uses `tokio` for async, `reqwest` for HTTP, `sqlx` or similar for SQLite access.
- It exposes Tauri commands that the frontend calls via `invoke`.

--------------------------------
RUNTIME & GLOBAL STATE
--------------------------------

App state struct (conceptual):

- Holds:
  - SQLite connection pool.
  - Crypto helper (for encrypting secrets).
  - Connector registry (Reddit, Google, cookie sites).
  - Scheduler handle (for jobs & alerts).

Example fields:

- db: sqlx::SqlitePool
- crypto: Crypto
- connectors: ConnectorRegistry
- scheduler: SchedulerHandle

This `AppState` is initialized once on app startup and injected into all Tauri commands via `State<AppState>`.

--------------------------------
DATABASE & PERSISTENCE (SQLite)
--------------------------------

The backend uses a single local SQLite database, e.g.:

- `~/.local/share/architect_cockpit/db.sqlite`

Core tables:

1. `users`:

- id INTEGER PK
- display_name TEXT
- created_at DATETIME

2. `account_connections`:

- id INTEGER PK
- user_id INTEGER FK → users.id
- provider TEXT           // 'reddit' | 'google_drive' | 'google_photos' | 'substack' | 'generic_site'
- login_type TEXT         // 'oauth' | 'password' | 'cookie'
- label TEXT              // friendly name
- external_user_id TEXT   // e.g. Reddit user id or Google "sub"
- secret_encrypted BLOB   // encrypted token / password / cookie jar
- meta TEXT               // JSON (scopes, refresh_token, expiry, domain, etc.)
- last_status TEXT        // 'ok' | 'error' | 'expired'
- created_at DATETIME
- updated_at DATETIME

3. `layouts`:

- id INTEGER PK
- user_id INTEGER FK
- name TEXT              // 'Writer Mode', 'Mod Mode', etc.
- config TEXT            // JSON of columns/panels
- created_at DATETIME
- updated_at DATETIME

4. `post_history`:

- id INTEGER PK
- user_id INTEGER FK
- provider TEXT           // 'reddit', 'substack', etc.
- target TEXT             // 'r/EndgameOrRepair', 'u/Daedalus', newsletter name
- external_post_id TEXT
- title TEXT
- body TEXT
- link_url TEXT
- created_at DATETIME     // actual publish time
- scheduled_for DATETIME NULL
- status TEXT             // 'pending' | 'published' | 'failed'

5. `jobs` (for scheduler):

- id INTEGER PK
- user_id INTEGER FK
- job_type TEXT           // 'scheduled_post', 'vacation_message', 'calendar_alert', etc.
- payload TEXT            // JSON payload per job type
- cron TEXT NULL          // for recurring jobs
- run_at DATETIME NULL    // next run time
- last_run_at DATETIME NULL
- status TEXT             // 'active' | 'paused' | 'completed' | 'error'

6. `calendar_events`:

- id INTEGER PK
- user_id INTEGER FK
- provider TEXT            // 'google'
- external_id TEXT
- title TEXT
- start_time DATETIME
- end_time DATETIME
- all_day INTEGER          // 0/1
- location TEXT
- description TEXT
- raw TEXT                 // JSON blob of original event
- last_synced_at DATETIME

7. `article_ideas`:

- id INTEGER PK
- user_id INTEGER FK
- title TEXT
- notes TEXT
- source_url TEXT
- status TEXT              // 'inbox' | 'planned' | 'drafting' | 'archived'
- tags TEXT                // JSON array of strings
- created_at DATETIME
- updated_at DATETIME

--------------------------------
SECURITY & ENCRYPTION
--------------------------------

Secrets stored in the DB (OAuth tokens, passwords, cookie jars) are encrypted.

- A master key is derived from a user passphrase (or OS keyring) using a KDF (Argon2/PBKDF2).
- Only a salt and KDF parameters are stored; the actual passphrase is not persisted.
- A helper type `Crypto` wraps AES-GCM encryption/decryption:

  - `encrypt(&self, plaintext: &[u8]) -> Vec<u8>`
  - `decrypt(&self, ciphertext: &[u8]) -> Vec<u8>`

- `account_connections.secret_encrypted` holds ciphertext.

The frontend may call a command like `set_passphrase` on first run to initialize the key.

--------------------------------
CONNECTOR ABSTRACTION
--------------------------------

To unify access to Reddit, Google, and cookie-based sites, the backend defines a trait (conceptually):

trait Connector {
    fn provider(&self) -> &'static str;

    async fn fetch_feed(
        &self,
        user_id: i64,
        params: FeedParams,
    ) -> Result<Vec<FeedItem>>;

    async fn submit_post(
        &self,
        user_id: i64,
        draft: PostDraft,
    ) -> Result<SubmitResult>;
}

Where:

- `FeedParams` contains pagination/filter info.
- `FeedItem` is a normalized feed item returned to the frontend.
- `PostDraft` and `PostTarget` describe what to post and where.
- `SubmitResult` includes external IDs and URLs.

Concrete connectors:

- `RedditConnector`:
  - Uses OAuth tokens stored in `account_connections`.
  - Calls Reddit APIs for:
    - User info
    - Subreddit feeds
    - Submissions
    - Mod queue and mod actions

- `GoogleDriveConnector`:
  - Uses Google OAuth tokens.
  - Lists recent/starred files.

- `GooglePhotosConnector`:
  - Uses Google OAuth tokens.
  - Lists media items.

- `CookieSiteConnector`:
  - For providers like Substack and other sites where:
    - No proper public API is used.
    - Login is done via email/password or cookie jar.
  - Uses stored cookies (and optionally passwords) from `account_connections`.
  - Performs HTTP requests as an authenticated user to fetch pages or submit forms.

A `ConnectorRegistry` holds these connector instances and allows fetching by provider string.

--------------------------------
AUTH FLOWS
--------------------------------

All auth happens locally inside the Tauri app.

1. Reddit OAuth:

- Tauri command `connect_reddit`:
  - Starts a tiny local HTTP server on `localhost:PORT`.
  - Opens the system browser to Reddit's OAuth URL with redirect back to `http://localhost:PORT/callback`.
- On callback:
  - Exchanges code for access_token + refresh_token.
  - Stores encrypted tokens in `account_connections`.
  - Fetches user info to populate `external_user_id`.

2. Google OAuth (Drive + Photos + Calendar):

- Similar pattern: local redirect URI + system browser.
- Requests scopes for:
  - Drive read/write as needed.
  - Photos access.
  - Calendar access (read/write, depending on needs).
- Tokens stored in `account_connections`.

3. Cookie-based / password sites (Substack, generic):

- Tauri command `connect_cookie_site(domain, email, password)`:
  - Performs login (via reqwest or a headless browser).
  - Captures resulting cookies (session, CSRF).
  - Encrypts and stores them in `account_connections` with:
    - provider: 'substack' or 'generic_site'
    - login_type: 'cookie' (and optionally also storing the encrypted password if re-login is needed).
- Subsequent requests use these cookies to fetch feeds or submit forms.

--------------------------------
SCHEDULER & CALENDAR SYNC
--------------------------------

The backend runs an in-process scheduler to handle:

- Scheduled posts (JobType::ScheduledPost).
- Vacation / auto-message jobs (JobType::VacationMessage).
- Calendar alerts (JobType::CalendarAlert).
- Periodic calendar sync.

Scheduler engine:

- On startup:
  - Loads all `jobs` where `status = 'active'`.
  - For each job, computes next `run_at`.
  - Spawns tokio tasks that:
    - Sleep until `run_at`.
    - Execute the job (e.g., submit a post via the appropriate connector).
    - Update `jobs` and, if recurring, compute the next `run_at`.

Calendar sync:

- Roughly every 30 minutes:
  - Uses Google Calendar connector to fetch upcoming events.
  - Upserts into `calendar_events`.
- This prevents hammering Google and allows offline alerts.

Calendar alerts:

- For each upcoming event:
  - Either create a `calendar_alert` job with `run_at = event.start_time - alert_offset`,
  - Or periodically scan `calendar_events` for events starting soon.
- When an alert triggers:
  - The backend emits a Tauri event (e.g. `"calendar_alert"`) with event details.
  - The frontend listens and shows focus-shift notifications.

--------------------------------
TAURI COMMANDS (BACKEND ENDPOINTS)
--------------------------------

The backend exposes commands that the frontend uses via `invoke`. Examples:

- `get_system_user() -> String`
  - Returns the OS user or display name.

- `get_mixed_feed(params) -> Vec<FeedItem>`
  - Aggregates feeds from connectors (Reddit, etc.).
  - Returns normalized items.

- `get_upcoming_events(horizonMinutes: i64) -> Vec<CalendarEvent>`
  - Reads from `calendar_events`.
  - Optionally triggers a sync if data is too old.

- `sync_calendar() -> ()`
  - Manually forces a calendar sync from Google to SQLite.

- `list_article_ideas(status: Option<String>) -> Vec<ArticleIdea>`
- `add_article_idea(...) -> ArticleIdea`
- `update_article_idea(...) -> ArticleIdea`
  - CRUD for the ideas inbox.

- `list_scheduled_jobs(...) -> Vec<Job>`
  - Returns jobs for AlertsPanel (scheduled posts, etc.).

- `create_scheduled_post(draft, run_at) -> Job`
  - Creates a scheduled post job.

- `take_mod_action(subreddit, post_id, action, reason) -> ()`
  - Uses RedditConnector to approve/remove/lock posts.

Frontend code should treat all of these as asynchronous `invoke` calls and use React Query to manage loading/error states.

--------------------------------
FRONTEND–BACKEND CONTRACT
--------------------------------

Frontend:

- Calls Tauri commands with well-defined names and parameter shapes.
- Uses TypeScript interfaces for:
  - FeedItem
  - CalendarEvent
  - ArticleIdea
  - Job
  - etc.

Backend:

- Implements each command.
- Ensures it reads/writes SQLite using the schemas above.
- Uses connectors and scheduler to perform external operations.

When generating frontend code, you DO NOT implement the backend, but you must respect this contract:

- Use the correct command names in `invoke`.
- Shape your TS types to match the conceptual Rust types described here.
