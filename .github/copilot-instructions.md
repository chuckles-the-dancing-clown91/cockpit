# Cockpit AI Agent Instructions

## Project Overview
Tauri 2.5 desktop app with Rust backend and React 19 frontend. Three modes: Writing (markdown editor, ideas), Research (news aggregation), System (settings, logs, tasks).

## Critical Build & Run Rules

### Always CD to Correct Directory First
**CRITICAL**: Commands fail silently if run from wrong directory.

**EVERY backend command MUST start with:**
```bash
cd /home/daddy/Documents/Commonwealth/cockpit/backend && <command>
```

**EVERY frontend command MUST start with:**
```bash
cd /home/daddy/Documents/Commonwealth/cockpit/frontend && <command>
```

### Build Process

**CRITICAL BUILD RULES**:
- âš ï¸ **NEVER use `cargo build --release`** - it corrupts the binary!
- âœ… **ALWAYS use `cargo tauri build`** for ALL production builds
- âœ… Use `cargo check` for quick syntax validation only (does NOT produce working binary)
- âœ… Use `cargo tauri dev` for development with hot reload

```bash
# DEVELOPMENT MODE (Recommended)
cd /home/daddy/Documents/Commonwealth/cockpit/backend && cargo tauri dev
# Runs Rust backend + frontend dev server with hot reload at http://localhost:5173

# PRODUCTION BUILD - ONLY correct way to build
cd /home/daddy/Documents/Commonwealth/cockpit/backend && cargo tauri build
# Creates .deb, .rpm, and portable binaries

# SYNTAX CHECKING ONLY (no binary)
cd /home/daddy/Documents/Commonwealth/cockpit/backend && cargo check

# Frontend only (for CI/testing)
cd /home/daddy/Documents/Commonwealth/cockpit/frontend && npm run build
```

**Build Output Locations**:
- Binary: `backend/target/release/cockpit` (from `cargo tauri build`)
- Frontend bundle: `frontend/dist/` (from `npm run build`)
- Platform packages: `backend/target/release/bundle/deb/` and `backend/target/release/bundle/rpm/`
- Portable installer: Generated by `scripts/build/package.sh` â†’ `dist/`

**Tauri Configuration**:
- Dev server: `http://localhost:5173` (Vite dev server)
- Frontend dist: `../frontend/dist` (relative to backend)
- Bundle targets: `["deb", "rpm"]`
- See `backend/tauri.conf.json` for window size, CSP, icons

**Never run cargo/npm commands without cd first - they will fail silently!**

## Frontend Architecture & Standards

### ğŸ¯ CURRENT ARCHITECTURE: 3-Tier with Feature Co-location

**Status**: Clean architecture implemented (Dec 2025)
- âœ… `frontend/src/` - Current production architecture
- âŒ `frontend/src-old/` - Legacy code, DO NOT USE

### Architecture Overview

```
frontend/src/
â”œâ”€â”€ core/                          # Infrastructure (shell, providers, stores, API)
â”‚   â”œâ”€â”€ api/tauri.ts              # Typed Tauri invoke wrappers
â”‚   â”œâ”€â”€ providers/                # Theme, Query, Toast, Dialog providers
â”‚   â”œâ”€â”€ stores/                   # Zustand stores (activeIdea, filters, etc.)
â”‚   â”œâ”€â”€ hooks/                    # useSettings, useCurrentUser, useCapabilities
â”‚   â”œâ”€â”€ lib/                      # toast.ts, cn.ts, formatters
â”‚   â”œâ”€â”€ theme/                    # ThemeProvider, tokens.css
â”‚   â””â”€â”€ components/
â”‚       â”œâ”€â”€ layout/               # AppShell, AppNavigation, Sidebar, ThemeSwitcher
â”‚       â””â”€â”€ ui/                   # Radix wrapper components (LoadingState, ErrorState, EmptyState)
â”œâ”€â”€ shared/                        # Domain types and constants
â”‚   â”œâ”€â”€ types.ts                  # Idea, Reference, IdeaStatus enum
â”‚   â”œâ”€â”€ constants.ts              # Status arrays, labels, colors
â”‚   â”œâ”€â”€ settings.ts               # SettingKey enum, SETTINGS_REGISTRY, SettingValueType<K>
â”‚   â”œâ”€â”€ queryKeys.ts              # Query key factory (queryKeys.ideas.detail(id))
â”‚   â””â”€â”€ utils/                    # Date formatters, string helpers
â”œâ”€â”€ features/                      # Reusable business UI (dumb components)
â”‚   â”œâ”€â”€ ideas/
â”‚   â”‚   â”œâ”€â”€ components/           # IdeaCard, IdeasList, IdeaDetailModal
â”‚   â”‚   â”œâ”€â”€ hooks/                # useIdeasQuery, useIdeaMutations
â”‚   â”‚   â””â”€â”€ index.ts              # Barrel exports
â”‚   â”œâ”€â”€ references/
â”‚   â”‚   â”œâ”€â”€ components/           # ReferenceCard, ReferencesList
â”‚   â”‚   â””â”€â”€ hooks/
â”‚   â”œâ”€â”€ notes/
â”‚   â”‚   â”œâ”€â”€ components/           # NotesEditor (TipTap), entity wrappers
â”‚   â”‚   â””â”€â”€ hooks/
â”‚   â””â”€â”€ writing/
â”‚       â”œâ”€â”€ components/           # TipTapEditor, WritingStats
â”‚       â””â”€â”€ hooks/
â”œâ”€â”€ domains/                       # Page compositions (smart pages)
â”‚   â”œâ”€â”€ writing/
â”‚   â”‚   â”œâ”€â”€ WritingView.tsx       # Domain coordinator with Radix Tabs
â”‚   â”‚   â”œâ”€â”€ EditorView.tsx        # Editor page with 2-column layout
â”‚   â”‚   â”œâ”€â”€ IdeasLibraryView.tsx  # Ideas page with filters
â”‚   â”‚   â””â”€â”€ ArchiveView.tsx       # Archive page
â”‚   â”œâ”€â”€ research/
â”‚   â”‚   â”œâ”€â”€ ResearchView.tsx      # Domain coordinator with Radix Tabs
â”‚   â”‚   â”œâ”€â”€ StreamView.tsx        # Unified article stream
â”‚   â”‚   â””â”€â”€ FeedSourcesView.tsx   # Feed source management
â”‚   â””â”€â”€ system/
â”‚       â”œâ”€â”€ SystemView.tsx        # Domain coordinator with Radix Tabs
â”‚       â”œâ”€â”€ SettingsView.tsx      # Settings grouped by category
â”‚       â”œâ”€â”€ StorageView.tsx       # Storage metrics, backups
â”‚       â”œâ”€â”€ LogsView.tsx          # Log viewer with filters
â”‚       â””â”€â”€ TasksView.tsx         # System task scheduler
â””â”€â”€ App.tsx                        # Main shell with routing
```

**Key Principles**:
1. **Features = Dumb UI** - Accept props, emit events, NO data fetching
2. **Domains = Smart Pages** - Compose features, manage state, handle queries
3. **Shared = Single Source of Truth** - Backend-aligned types and constants
4. **Core = Infrastructure** - Providers, stores, API wrappers, hooks
5. **ALL components use Radix UI primitives + CSS custom properties**
6. **Type-safe settings** - `useSetting<K>(SettingKey.*)` with generics

### UI Component Library: Radix Themes
**CRITICAL**: ALL UI components MUST use Radix Themes (https://www.radix-ui.com/themes)

**Why Radix Themes:**
- Pre-styled accessible components (WAI-ARIA compliant)
- Full keyboard navigation and theme support
- Focus management out of the box
- Composable primitives for complete control
- No conflicting styles with our CSS custom properties

**Required Pattern for Modals/Dialogs:**
```tsx
import * as Dialog from '@radix-ui/react-dialog';

export function MyDialog({ open, onClose }) {
  return (
    <Dialog.Root open={open} onOpenChange={onClose}>
      <Dialog.Portal>
        <Dialog.Overlay className="fixed inset-0 z-40 bg-[color:var(--color-overlay-scrim)] backdrop-blur-[2px]" />
        <Dialog.Content className="fixed left-1/2 top-1/2 z-50 -translate-x-1/2 -translate-y-1/2 w-[min(800px,100%-2rem)] max-h-[90vh] flex flex-col overflow-hidden rounded-[var(--radius-card)] border border-[var(--color-border)] bg-[var(--color-surface-soft)] shadow-[var(--shadow-card-elevated)] text-[var(--color-text-primary)]">
          <div className="flex items-center justify-between p-6 border-b border-[var(--color-border-subtle)] bg-[var(--color-surface)]">
            <Dialog.Title className="text-xl font-semibold text-[var(--color-text-primary)]">
              Title
            </Dialog.Title>
            <Dialog.Close asChild>
              <button className="p-1 hover:bg-[var(--color-surface-hover)] rounded transition-colors">
                <X className="h-5 w-5" />
              </button>
            </Dialog.Close>
          </div>
          {/* Content */}
        </Dialog.Content>
      </Dialog.Portal>
    </Dialog.Root>
  );
}
```

**CSS Custom Properties (Always Use):**
- Backgrounds: `var(--color-surface)`, `var(--color-surface-soft)`, `var(--color-surface-hover)`
- Text: `var(--color-text-primary)`, `var(--color-text-soft)`, `var(--color-text-muted)`
- Borders: `var(--color-border)`, `var(--color-border-subtle)`
- Interactive: `var(--color-primary)`, `var(--color-primary-hover)`
- Radius: `var(--radius-card)`, `var(--radius-input)`
- Shadows: `var(--shadow-card)`, `var(--shadow-card-elevated)`

**Input/Form Styling (Standard Pattern):**
```tsx
<input
  className="w-full px-3 py-2 border border-[var(--color-border)] rounded-md bg-[var(--color-surface)] text-[var(--color-text-primary)] placeholder:text-[var(--color-text-soft)]"
/>
```

**Reference Implementation:**
- See `frontend/src/components/news/NewsFeedDialog.tsx` for complete modal example
- See `frontend/src/components/research/FeedSourceDialog.tsx` for form patterns

**NEVER:**
- âŒ Use plain `<div>` wrappers for modals (causes transparency issues)
- âŒ Use Tailwind color classes directly (`bg-gray-100`, `text-white`) - always use CSS custom properties
- âŒ Skip accessibility attributes - Radix handles this automatically
- âŒ Create custom dropdown/select implementations - use Radix primitives

**Available Radix Primitives:**
- Dialog (modals, popovers)
- Toast (notifications - use `@/core/lib/toast`)
- Dropdown Menu
- Select
- Tooltip
- Accordion
- Tabs
- Radio Group
- Checkbox
- Switch
- Slider
- Progress
- ScrollArea
- HoverCard
- Popover
- AlertDialog

## Environment Configuration

### Required .env Variables (backend/.env OR ~/.cockpit/.env)
**CRITICAL**: First-run setup auto-generates `~/.cockpit/.env` with secure defaults.

**Development vs Production**:
- **Development**: Can use `backend/.env` (local, git-ignored)
- **Production**: Uses `~/.cockpit/.env` (auto-created on first run)
- App searches `~/.cockpit/.env` first, then falls back to `backend/.env`

**Auto-Generated .env (First Run)**:
```bash
# Created automatically by ensure_first_run_setup()
COCKPIT_HOME=~/.cockpit
DATABASE_URL=sqlite:~/.cockpit/data/db.sql
STORAGE_ROOT=~/.cockpit
LOGS_DIR=~/.cockpit/logs

# Auto-generated 256-bit key (DO NOT SHARE)
COCKPIT_MASTER_KEY=<64-char-hex>   # Generated with rand::rng()

# Optional - configure via Settings UI
NEWSDATA_API_KEY=<your-key>

LOG_LEVEL=info
LOG_JSON=true
LOG_CONSOLE=true
LOG_MAX_SIZE_MB=10
LOG_MAX_FILES=5
DB_MAX_CONNECTIONS=5
DB_MIN_CONNECTIONS=1
STORAGE_MAX_SIZE_GB=50
NEWSDATA_DAILY_LIMIT=180
```

**Manual Setup (Development Only)**:
```bash
# Generate master key
openssl rand -hex 32

# Create backend/.env
cd backend
cat > .env << EOF
COCKPIT_MASTER_KEY=<generated-key>
DATABASE_URL=sqlite:$(pwd)/storage/data/db.sql
STORAGE_ROOT=$(pwd)/storage
LOGS_DIR=$(pwd)/storage/logs
LOG_LEVEL=debug
EOF
```

**Common Silent Failures**: 
- Using `MASTER_KEY` instead of `COCKPIT_MASTER_KEY` causes immediate exit with no error
- Using relative paths causes file not found errors when running from different directories
- Missing master key causes encryption operations to fail silently

**Encryption Details**:
- Algorithm: AES-256-GCM (authenticated encryption)
- Key: 256 bits (32 bytes hex-encoded â†’ 64 chars)
- Nonce: 96 bits (12 bytes), randomly generated per encryption
- Storage format: `[12-byte nonce][ciphertext + auth tag]`
- Used for: API keys, sensitive settings
- See: `backend/src/core/components/crypto.rs`

## Architecture Patterns

### Domain-Driven Structure
Each domain owns its business logic and Tauri command interface:

```
backend/src/
â”œâ”€â”€ core/           # Infrastructure (db, config, logging, storage)
â”œâ”€â”€ writing/        # Ideas management domain
â”œâ”€â”€ research/       # News & feeds domain  
â”œâ”€â”€ system/         # Scheduler & tasks domain
â””â”€â”€ util/           # Cross-domain utilities

domain/
â”œâ”€â”€ components/     # Business logic (pure Rust functions)
â”œâ”€â”€ commands.rs     # Tauri commands (thin wrappers)
â””â”€â”€ mod.rs
```

**Pattern**: Commands in `domain/commands.rs` call handlers in `domain/components/*.rs`. Never put business logic in commands.rs.

### Knowledge Graph Feature (Writing Domain)

**Complete CRUD API** for many-to-many knowledge graph (26 commands):
- **Reference Items** (5 commands): `kg_list_references`, `kg_get_reference`, `kg_create_reference`, `kg_update_reference`, `kg_delete_reference`
- **Writings** (6 commands): `kg_list_writings`, `kg_get_writing`, `kg_create_writing`, `kg_update_writing`, `kg_publish_writing`, `kg_delete_writing`
- **Idea â†” Reference Links** (4 commands): `kg_link_idea_reference`, `kg_unlink_idea_reference`, `kg_list_references_for_idea`, `kg_list_ideas_for_reference`
- **Writing â†” Idea Links** (4 commands): `kg_link_writing_idea`, `kg_unlink_writing_idea`, `kg_list_ideas_for_writing`, `kg_list_writings_for_idea`
- **Notes** (5 commands): `kg_list_notes_for_entity`, `kg_get_note`, `kg_create_note`, `kg_update_note`, `kg_delete_note`

**Handler Location**: `backend/src/writing/components/knowledge_graph/handlers/`
- `reference_items.rs` (230 lines) - Reference CRUD with type enum validation
- `writings.rs` (288 lines) - Writing CRUD with status workflow (draftâ†’published)
- `links.rs` (234 lines) - Many-to-many link management with role/purpose
- `notes.rs` (197 lines) - Polymorphic notes on any entity

**Key Patterns**:
- DTOs use camelCase serialization for frontend compatibility
- All enums have `Display` trait for `.to_string()` support
- Type-safe enum parsing from strings with validation
- Pagination with SeaORM's `paginate()` + `fetch_page()`
- Delete operations use `Entity::delete_by_id()` for efficiency

### Example: Adding a New Feature
```rust
// 1. Add handler in domain/components/
pub async fn get_thing(db: &DatabaseConnection, id: i64) -> AppResult<Thing> {
    // business logic here
}

// 2. Add Tauri command in domain/commands.rs
#[tauri::command]
pub async fn get_thing_handler(state: State<'_, AppState>, id: i64) -> Result<Thing, String> {
    components::thing::get_thing(&state.db, id)
        .await
        .map_err(|e| e.to_string())
}

// 3. Register in main.rs
.invoke_handler(tauri::generate_handler![
    // ...existing commands,
    get_thing_handler,
])
```

### Frontend Query Pattern (TanStack Query)
```typescript
// hooks/queries.ts
export function useThing(id: number) {
  return useQuery({
    queryKey: ['thing', id],
    queryFn: () => invoke<Thing>('get_thing_handler', { id }),
  });
}

// Mutations invalidate related queries
const mutation = useMutation({
  mutationFn: (data) => invoke('update_thing', data),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['thing'] });
  },
});
```

## State Management

### TanStack Query (React Query v5)
**Use for**: Server state, data fetching, caching

```tsx
import { useQuery, useMutation } from '@tanstack/react-query';
import { queryKeys } from '@/shared/queryKeys';

const { data } = useQuery({
  queryKey: queryKeys.ideas.detail(id),
  queryFn: () => invoke('get_idea', { id }),
});
```

### Zustand
**Use for**: Cross-view UI state (selections, filters, temporary state)
**Don't use for**: Server data (use TanStack Query)

```tsx
import { create } from 'zustand';

const useStore = create((set) => ({
  activeId: null,
  setActive: (id) => set({ activeId: id }),
}));
```

## Database & Storage

### Database Location
```bash
backend/storage/data/db.sql      # Database file (when run from backend/)
~/.cockpit/data/db.sql          # Production location (auto-created)
```

**Migration System** (SeaORM Migration Framework):
- Location: `backend/migration/src/m00X_*.rs` (Rust modules)
- Applied via SeaORM `Migrator::up()` (type-safe, database-agnostic)
- Current schema version: 006 (Knowledge Graph)
- Migrations run automatically on startup
- Tracking table: `seaql_migrations` (auto-created)

**Active Migrations** (All converted to SeaORM Migration):
1. `m001_initial_schema.rs` (542 lines) - Core tables (ideas, news_articles, news_sources, system_tasks)
2. `m002_app_settings.rs` (145 lines) - Settings table with categories, 21 default settings
3. `m003_performance_indexes.rs` (118 lines) - Composite indexes for query optimization
4. `m004_feed_sources.rs` (241 lines) - Plugin-based feed aggregation (NewsData.io, etc.)
5. `m005_idea_references.rs` (169 lines) - Idea â†” Resources many-to-many (legacy, use 006 instead)
6. `m006_writing_knowledge_graph.rs` (600 lines) - Complete knowledge graph:
   - `reference_items` - Unified source table (news_article/url/tweet/paper/book/pdf/manual)
   - `writings` - Content outputs (article/chapter/book, draftâ†’published workflow)
   - `idea_reference_links` - Idea â†” Reference many-to-many with role (supporting/counter/quote)
   - `writing_idea_links` - Writing â†” Idea many-to-many with purpose (primary/secondary/mention)
   - `notes` - Polymorphic notes (on ideas/references/writings with type: highlight/annotation/todo)

**Adding New Migrations**:
```bash
# 1. Create new migration file
cd backend/migration/src
cat > m007_feature_name.rs << 'EOF'
use sea_orm_migration::prelude::*;

#[derive(DeriveMigrationName)]
pub struct Migration;

#[async_trait::async_trait]
impl MigrationTrait for Migration {
    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager.create_table(
            Table::create()
                .table(MyTable::Table)
                .if_not_exists()
                .col(ColumnDef::new(MyTable::Id).big_integer().auto_increment().primary_key())
                .col(ColumnDef::new(MyTable::Name).string().not_null())
                .to_owned()
        ).await
    }

    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager.drop_table(Table::drop().table(MyTable::Table).to_owned()).await
    }
}

#[derive(DeriveIden)]
enum MyTable {
    Table,
    Id,
    Name,
}
EOF

# 2. Register in lib.rs
# Add to vec![...] in backend/migration/src/lib.rs:
#   Box::new(m007_feature_name::Migration),

# 3. Migrations run automatically on next app start
```

**Migration Best Practices** (Database Portability):
- âœ… Use `.big_integer()` for IDs (not raw INTEGER)
- âœ… Use `.string()` or `.string_len(N)` for text (not raw TEXT)
- âœ… Use `.timestamp()` for dates (not raw DATETIME)
- âœ… Store enums as TEXT strings: "draft", "in_progress" (not SQL ENUM)
- âœ… Store JSON as TEXT, parse with `serde_json` (not JSON column type)
- âœ… Use `ForeignKey::create()` builder (portable constraints)
- âŒ Avoid raw SQL: `manager.execute_statement()` (breaks portability)
- âŒ Avoid SQLite-specific: FTS, partial indexes with WHERE

**Why SeaORM Migration?**
- **Type-safe**: Compile-time validation of schema
- **Portable**: Same code generates SQLite/PostgreSQL/MySQL SQL
- **Maintainable**: Rust patterns, IDE autocomplete, refactoring
- **Consistent**: Migrations match entity definitions exactly

### Log Parsing (Critical Detail)
`get_logs()` in `storage.rs` parses **both formats**:
- **JSON**: `{"timestamp":"...","level":"INFO","fields":{"message":"..."},"target":"..."}`  
- **Plain text**: `2025-12-12T19:15:18.764156Z  INFO backend::module: message`

**Log Separation**:
- **app.log** - Application logs (shown in Logs view)
- **api_calls.log** - API request/response logs (excluded from main view to reduce clutter)
- **errors.log** - Error-level logs only

The Logs view automatically excludes `api_calls.log` to keep the UI clean. API logs contain verbose JSON responses from news feeds and should be viewed separately or via a dedicated API logs section.

**Log Separation**:
- **app.log** - Application logs (shown in Logs view)
- **api_calls.log** - API request/response logs (excluded from main view to reduce clutter)
- **errors.log** - Error-level logs only

The Logs view automatically excludes `api_calls.log` to keep the UI clean. API logs contain verbose JSON responses from news feeds and should be viewed separately or via a dedicated API logs section.

## Common Pitfalls

1. **Silent Exit on Startup**: Check `COCKPIT_MASTER_KEY` exists and is 64 hex chars
2. **Empty Log View**: Logs written to `storage/logs/app.log` - parser handles both JSON/text
3. **Build Fails**: Ensure you're in `backend/` directory before running cargo commands
4. **Frontend API Errors**: Check command is registered in `main.rs` invoke_handler
5. **Database Corruption**: Backup system in `storage/backups/` - use `restore_database_from_backup` command

## Testing & Debugging

```bash
# Backend with verbose logging
cd backend
RUST_LOG=debug RUST_BACKTRACE=1 cargo run

# Check logs
tail -f backend/storage/logs/app.log

# Test specific command
cd backend && cargo test test_name

# Frontend dev mode (hot reload)
cd frontend && npm run dev
```

## Key Files to Understand

- `backend/src/main.rs` - App setup, command registration (140 lines)
- `backend/src/core/config.rs` - All environment variables, validation (296 lines)
- `backend/src/core/components/storage.rs` - Log parsing, backups, cleanup (1445 lines)
- `frontend/src/hooks/queries.ts` - All backend API calls
- `backend/tauri.conf.json` - Tauri configuration, permissions

## Modular Design Philosophy

### Domain Isolation
The codebase follows a strict modular architecture where domains are self-contained:

**Core Domains**:
- **core/** - Infrastructure (database, config, logging, storage, crypto)
- **writing/** - Content creation and ideas management
- **research/** - News aggregation, articles, sources
- **system/** - Task scheduler, cron jobs, execution tracking
- **util/** - Cross-domain utilities

**Key Principles**:
1. **Business logic** stays in `domain/components/` - pure Rust functions
2. **Tauri commands** in `domain/commands.rs` - thin wrappers only
3. **Minimal cross-dependencies** - domains communicate through AppState
4. **Clear boundaries** - each domain has its own data structures and handlers
5. **main.rs stays thin** - only setup and command registration

### Adding Features (Step-by-Step)

**1. Identify domain** - Where does this feature belong?
**2. Add business logic** - Create handler in `domain/components/feature.rs`
**3. Create command** - Wrap handler in `domain/commands.rs`
**4. Register command** - Add to `main.rs` invoke_handler
**5. Frontend integration** - Add query/mutation to `frontend/src/hooks/queries.ts`
**6. UI component** - Create/update view in `frontend/src/components/domain/`

### Parallel Development
The modular structure enables multiple developers to work simultaneously without conflicts:
- Writing features â†’ `writing/` directory
- Research features â†’ `research/` directory  
- System features â†’ `system/` directory
- Core infrastructure â†’ `core/` directory

## Production Distribution & Packaging

### First-Run Setup (Implemented)
On first run, `ensure_first_run_setup()` in `backend/src/core/components/setup.rs` automatically:
1. Detects no `~/.cockpit/` directory exists
2. Creates directory structure:
   - `~/.cockpit/data/` - Database and user data
   - `~/.cockpit/logs/` - Application logs (app.log, api_calls.log, errors.log)
   - `~/.cockpit/cache/` - Temporary cache
   - `~/.cockpit/backups/` - Database backups
   - `~/.cockpit/exports/` - Exported data
3. Generates cryptographically secure 256-bit master key
4. Creates `~/.cockpit/.env` with default configuration
5. Returns `true` to indicate first run completed

**Setup Flow**:
```rust
// In main.rs
let is_first_run = core::components::setup::ensure_first_run_setup()?;
if is_first_run {
    info!("âœ“ First-run setup complete!");
}
```

### Development vs Production Paths
- **Development**: Can use `backend/.env` and `backend/storage/` (local, git-ignored)
- **Production**: Uses `~/.cockpit/.env` and `~/.cockpit/` (user home directory)
- App loads `~/.cockpit/.env` first, falls back to `backend/.env`
- Portable between dev and production seamlessly

### Building Packages

**Scripts** (in `scripts/build/`):
```bash
# Full production build with .deb and .rpm packages
./scripts/build/package.sh
# Output: dist/Cockpit_0.1.0_amd64.deb, dist/Cockpit-0.1.0-1.x86_64.rpm

# Quick build for testing
./scripts/build/package-quick.sh

# Complete build with validation
./scripts/build/build-complete.sh

# Simple development build
./scripts/build/build.sh
```

**Package Details**:
- .deb dependencies: `libgtk-3-0 (>= 3.24)`, `libwebkit2gtk-4.1-0 (>= 2.40)`, `libayatana-appindicator3-1`
- Desktop file: `backend/cockpit.desktop`
- Post-install: `backend/postinst.sh` (creates ~/.cockpit, sets permissions)
- Icons: `backend/icons/` (16x16 to 512x512 PNG)
- See `backend/tauri.conf.json` for bundle configuration

## Complete Frontend Infrastructure Reference

### ğŸ¯ Core Hooks & Utilities (ALWAYS USE THESE)

**Settings Management** (`core/hooks/useSettings.ts`):
```tsx
import { useSettings, useSetting, useUpdateSetting, useCapabilities } from '@/core/hooks/useSettings';
import { SettingKey, SETTINGS_REGISTRY } from '@/shared/settings';

// Get all settings (rarely needed, prefer specific hooks)
const { data: settings } = useSettings();

// Get specific setting (type-safe, recommended)
const theme = useSetting(SettingKey.AppTheme); // Returns 'dark' | 'light' | 'cyberpunk'
const autoSave = useSetting(SettingKey.WritingAutoSave); // Returns boolean

// Update setting (type-safe)
const updateSetting = useUpdateSetting();
await updateSetting(SettingKey.AppTheme, 'dark'); // Type-checked value

// Check feature availability
const { isLoading, news, google, reddit, x } = useCapabilities();
if (news.enabled) { /* show news features */ }
```

**Theme System** (`core/providers/ThemeProvider.tsx`):
```tsx
import { useTheme } from '@/core/providers/ThemeProvider';
import { ThemeSwitcher } from '@/core/components/theme/ThemeSwitcher';

const { theme, setTheme } = useTheme(); // Current: 'dark' | 'light' | 'cyberpunk'
setTheme('cyberpunk'); // Updates localStorage + CSS classes

// Or use pre-built ThemeSwitcher component (recommended)
<ThemeSwitcher /> // Dropdown with icons, persistence included
```

**Toast Notifications** (`core/lib/toast.ts`):
```tsx
import { toast } from '@/core/lib/toast';

toast.success('Settings saved successfully');
toast.error('Failed to update setting');
toast.info('Theme changed to dark mode');
// NOT: import { toast } from 'sonner'; âŒ WRONG LIBRARY
```

**Dialogs** (`core/providers/DialogProvider.tsx`):
```tsx
import { useDialog } from '@/core/providers/DialogProvider';

const dialog = useDialog();

// Confirm dialog (promise-based)
const confirmed = await dialog.confirm({
  title: 'Delete Item',
  description: 'Are you sure? This cannot be undone.',
});
if (confirmed) { /* delete */ }

// Prompt dialog
const result = await dialog.prompt({
  title: 'Enter Name',
  description: 'What should we call this?',
  placeholder: 'My Item',
});
```

**Query Keys** (`shared/queryKeys.ts`):
```tsx
import { queryKeys } from '@/shared/queryKeys';
import { useQueryClient } from '@tanstack/react-query';

const queryClient = useQueryClient();

// Use centralized keys (NOT hardcoded strings)
useQuery({ queryKey: queryKeys.settings.all() }); // ['settings']
useQuery({ queryKey: queryKeys.ideas.detail(123) }); // ['ideas', 123]

// Invalidate queries
queryClient.invalidateQueries({ queryKey: queryKeys.settings.all() });
```

**Current User** (`core/hooks/useCurrentUser.ts`):
```tsx
import { useCurrentUser } from '@/core/hooks/useCurrentUser';

const { data: user, isLoading } = useCurrentUser();
// user.username, user.homeDir, user.userId
```

**State Components** (`core/components/ui/`):
```tsx
import { LoadingState, ErrorState, EmptyState } from '@/core/components/ui';

// Loading
if (isLoading) return <LoadingState />;
if (isLoading) return <LoadingState.Inline />; // Compact variant

// Error
if (error) return <ErrorState message={error.message} onRetry={() => refetch()} />;

// Empty state
if (data.length === 0) {
  return (
    <EmptyState
      title="No ideas yet"
      description="Create your first idea to get started"
      actionLabel="New Idea"
      onAction={handleNewIdea}
    />
  );
}
```

### ğŸš« Common Mistakes to Avoid

**DON'T**:
- âŒ Create local `useSettings` hooks in features/domains
- âŒ Import `toast` from `sonner` library (use `@/core/lib/toast`)
- âŒ Hardcode query keys like `['settings']` (use `queryKeys.settings.all()`)
- âŒ Access settings with string patterns like `settings?.category?.['key']?.value`
- âŒ Convert booleans to strings ('true'/'false') - use proper types
- âŒ Hardcode labels/descriptions (use `SETTINGS_REGISTRY` metadata)
- âŒ Use native HTML form elements (use Radix UI primitives)
- âŒ Create custom dropdown/select components (use Radix Select)

**DO**:
- âœ… Use type-safe hooks: `useSetting<K>(SettingKey.*)`, `useUpdateSetting<K>()`
- âœ… Use custom toast: `toast.success()`, `toast.error()`
- âœ… Use query keys factory: `queryKeys.domain.action()`
- âœ… Use `SettingKey` enum for all setting references
- âœ… Use boolean values directly (not string conversion)
- âœ… Use `SETTINGS_REGISTRY` for UI metadata
- âœ… Use Radix UI for all interactive components


### ğŸ“ Settings Registry Usage

**SETTINGS_REGISTRY** provides complete metadata for every setting:

```tsx
import { SETTINGS_REGISTRY, getSettingsByCategory } from '@/shared/settings';

// Get metadata for a setting
const metadata = SETTINGS_REGISTRY[SettingKey.AppTheme];
// { key, label, description, category, type, options, min, max, step }

// Get all settings in a category
const generalSettings = getSettingsByCategory('general');
generalSettings.forEach(setting => {
  // Use setting.label, setting.description, setting.type, etc.
  // Dynamically render UI based on setting.type:
  // - 'boolean' â†’ <Switch />
  // - 'number' â†’ <input type="number" min={setting.min} max={setting.max} />
  // - 'string' with options â†’ <Select options={setting.options} />
});
```

### ğŸ¨ Styling with CSS Custom Properties

**ALWAYS** use CSS custom properties, never Tailwind color classes:

```tsx
// âœ… CORRECT
<div className="bg-[var(--color-surface)] border-[var(--color-border)]">
  <Text className="text-[var(--color-text-primary)]">Hello</Text>
</div>

// âŒ WRONG
<div className="bg-gray-100 border-gray-300">
  <Text className="text-white">Hello</Text>
</div>
```

**Available CSS Variables**:
- Surfaces: `--color-surface`, `--color-surface-soft`, `--color-surface-hover`
- Text: `--color-text-primary`, `--color-text-soft`, `--color-text-muted`
- Borders: `--color-border`, `--color-border-subtle`
- Interactive: `--color-primary`, `--color-primary-hover`
- Radius: `--radius-card`, `--radius-input`
- Shadows: `--shadow-card`, `--shadow-card-elevated`
- Overlay: `--color-overlay-scrim`

### ğŸ”Œ Wiring Theme to Settings Backend

When building components that need theme switching:

```tsx
import { useTheme } from '@/core/providers/ThemeProvider';
import { useSetting, useUpdateSetting } from '@/core/hooks/useSettings';
import { SettingKey } from '@/shared/settings';
import { useEffect } from 'react';

const { theme, setTheme } = useTheme();
const backendTheme = useSetting(SettingKey.AppTheme);
const updateSetting = useUpdateSetting();

// Sync backend â†’ UI on load
useEffect(() => {
  if (backendTheme && backendTheme !== theme) {
    setTheme(backendTheme);
  }
}, [backendTheme, theme, setTheme]);

// Update both backend + UI on change
const handleThemeChange = async (newTheme: 'dark' | 'light' | 'cyberpunk') => {
  setTheme(newTheme); // Instant UI update
  await updateSetting(SettingKey.AppTheme, newTheme); // Persist to backend
};
```

## Workflow Tips

- **Before making changes**: Check if infrastructure already exists (settings hooks, toast, theme, etc.)
- **When adding settings**: Use `SettingKey` enum, never hardcoded strings
- **When showing toasts**: Import from `@/core/lib/toast`, not `sonner`
- **When creating modals**: Use Radix Dialog primitives, not plain divs
- **When styling**: Use CSS custom properties (var(--color-*)), not Tailwind colors
- **After editing Rust**: Rebuild from `backend/` directory
- **After editing commands**: Verify registration in `main.rs`
- **When adding queries**: Use `queryKeys` factory from `shared/queryKeys.ts`
- **Database changes**: Add migration, increment version, test on fresh DB
- **Cross-domain needs**: Use AppState or create util function, don't couple domains
