use std::fs;
use std::path::PathBuf;
use serde::{Deserialize, Serialize};
use tracing::info;
use super::errors::{AppError};
use super::setup::get_cockpit_home;

#[derive(Debug, Serialize, Deserialize)]
pub struct SetupStatus {
    pub is_complete: bool,
    pub has_master_key: bool,
    pub has_database: bool,
    pub cockpit_home: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SetupConfig {
    pub master_key: String,
    pub newsdata_api_key: Option<String>,
    pub log_level: Option<String>,
}

/// Checks if initial setup is complete
pub fn check_setup_status() -> Result<SetupStatus, AppError> {
    let cockpit_home = get_cockpit_home()?;
    let env_file = cockpit_home.join(".env");
    let db_file = cockpit_home.join("data").join("db.sql");
    
    let has_env = env_file.exists();
    let has_database = db_file.exists();
    
    // Check if master key is set in .env
    let has_master_key = if has_env {
        check_master_key_exists(&env_file)?
    } else {
        false
    };
    
    let is_complete = has_master_key && has_database;
    
    Ok(SetupStatus {
        is_complete,
        has_master_key,
        has_database,
        cockpit_home: cockpit_home.to_string_lossy().to_string(),
    })
}

/// Generates a cryptographically secure random master key (64 hex characters)
pub fn generate_master_key() -> String {
    use rand::RngCore;
    let mut bytes = [0u8; 32];
    rand::rng().fill_bytes(&mut bytes);
    hex::encode(bytes)
}

/// Saves the setup configuration to ~/.cockpit/.env
pub fn save_setup_config(config: SetupConfig) -> Result<(), AppError> {
    let cockpit_home = get_cockpit_home()?;
    let env_file = cockpit_home.join(".env");
    
    // Validate master key
    if config.master_key.len() != 64 {
        return Err(AppError::Validation {
            field: "master_key".to_string(),
            reason: "Master key must be exactly 64 hex characters".to_string(),
            invalid_value: Some(format!("length: {}", config.master_key.len())),
        });
    }
    
    if !config.master_key.chars().all(|c| c.is_ascii_hexdigit()) {
        return Err(AppError::Validation {
            field: "master_key".to_string(),
            reason: "Master key must contain only hexadecimal characters (0-9, a-f)".to_string(),
            invalid_value: None,
        });
    }
    
    // Build .env content
    let mut env_content = String::new();
    env_content.push_str("# Cockpit Configuration\n");
    env_content.push_str("# Generated by setup wizard\n\n");
    
    env_content.push_str("# Storage Paths\n");
    env_content.push_str(&format!("COCKPIT_HOME={}\n", cockpit_home.to_string_lossy()));
    env_content.push_str(&format!("DATABASE_URL=sqlite:{}/data/db.sql\n", cockpit_home.to_string_lossy()));
    env_content.push_str(&format!("STORAGE_ROOT={}\n", cockpit_home.to_string_lossy()));
    env_content.push_str(&format!("LOGS_DIR={}/logs\n\n", cockpit_home.to_string_lossy()));
    
    env_content.push_str("# Security (REQUIRED)\n");
    env_content.push_str(&format!("COCKPIT_MASTER_KEY={}\n\n", config.master_key));
    
    if let Some(api_key) = config.newsdata_api_key {
        if !api_key.is_empty() {
            env_content.push_str("# API Keys\n");
            env_content.push_str(&format!("NEWSDATA_API_KEY={}\n\n", api_key));
        }
    }
    
    env_content.push_str("# Logging Configuration\n");
    let log_level = config.log_level.unwrap_or_else(|| "info".to_string());
    env_content.push_str(&format!("LOG_LEVEL={}\n", log_level));
    env_content.push_str("LOG_JSON=true\n");
    env_content.push_str("LOG_CONSOLE=true\n");
    env_content.push_str("LOG_MAX_SIZE_MB=10\n");
    env_content.push_str("LOG_MAX_FILES=5\n\n");
    
    env_content.push_str("# Database Configuration\n");
    env_content.push_str("DB_MAX_CONNECTIONS=5\n");
    env_content.push_str("DB_MIN_CONNECTIONS=1\n\n");
    
    env_content.push_str("# Storage Limits\n");
    env_content.push_str("STORAGE_MAX_SIZE_GB=50\n\n");
    
    env_content.push_str("# News API Configuration\n");
    env_content.push_str("NEWSDATA_DAILY_LIMIT=180\n");
    
    // Write to file with secure permissions
    fs::write(&env_file, env_content)
        .map_err(|e| AppError::FileOperation {
            operation: "write .env file".to_string(),
            path: env_file.to_string_lossy().to_string(),
            source: e,
        })?;
    
    // Set file permissions to 600 (owner read/write only)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&env_file)
            .map_err(|e| AppError::FileOperation {
                operation: "get .env permissions".to_string(),
                path: env_file.to_string_lossy().to_string(),
                source: e,
            })?
            .permissions();
        perms.set_mode(0o600);
        fs::set_permissions(&env_file, perms)
            .map_err(|e| AppError::FileOperation {
                operation: "set .env permissions".to_string(),
                path: env_file.to_string_lossy().to_string(),
                source: e,
            })?;
    }
    
    info!("Setup configuration saved to {:?}", env_file);
    Ok(())
}

/// Checks if master key exists in .env file
fn check_master_key_exists(env_file: &PathBuf) -> Result<bool, AppError> {
    let content = fs::read_to_string(env_file)
        .map_err(|e| AppError::FileOperation {
            operation: "read .env file".to_string(),
            path: env_file.to_string_lossy().to_string(),
            source: e,
        })?;
    
    // Look for COCKPIT_MASTER_KEY that's not a placeholder
    for line in content.lines() {
        let line = line.trim();
        if line.starts_with("COCKPIT_MASTER_KEY=") {
            let value = line.trim_start_matches("COCKPIT_MASTER_KEY=");
            // Check if it's not empty and not a placeholder
            if !value.is_empty() 
                && !value.contains("CHANGE_ME") 
                && !value.contains("your_key_here")
                && value.len() == 64 
            {
                return Ok(true);
            }
        }
    }
    
    Ok(false)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_master_key() {
        let key = generate_master_key();
        assert_eq!(key.len(), 64);
        assert!(key.chars().all(|c| c.is_ascii_hexdigit()));
    }
    
    #[test]
    fn test_generate_multiple_keys_are_different() {
        let key1 = generate_master_key();
        let key2 = generate_master_key();
        assert_ne!(key1, key2);
    }
}
