
Architect Cockpit – cron-job.txt
================================

Purpose
-------

Define the specification for the **system task scheduler** used by Architect Cockpit.

This scheduler is responsible for:

- Running recurring system jobs (e.g. news sync, calendar sync).
- Tracking last run, status, results, and errors.
- Exposing control & visibility to the frontend via Tauri commands and events.
- Allowing “Run now” actions from the UI without breaking the schedule.

This is not runnable code; it is a design document for code generation (Codex)
and human implementation.


=========================================
1. ARCHITECTURE OVERVIEW
=========================================

High-level model:

- **Storage layer (SQLite)**:
  - `system_tasks` table defines each job (type, component, schedule, status).
  - `system_task_runs` table (optional) stores history of runs for debugging.

- **Scheduler engine (Rust + Tokio)**:
  - On backend startup, loads enabled tasks from DB.
  - For each task, spawns an async loop that:
    - Waits until next scheduled time.
    - Executes the handler for that task type.
    - Updates DB with result.
    - Emits events to the frontend via Tauri.

- **Handlers (Rust)**:
  - Functions that implement real work:
    - e.g. `handle_news_sync_task`, `handle_calendar_sync_task`.
  - Handlers know nothing about timing; they just execute once when called.

- **Frontend integration (React)**:
  - Uses Tauri commands to:
    - List tasks, see status, change frequency, enable/disable.
    - Trigger “Run now”.
  - Listens to Tauri events to:
    - Show toasts when jobs finish.
    - Update metric cards (e.g. Feed items, Events, Alerts).


=========================================
2. DATABASE SCHEMA
=========================================

2.1 Table: system_tasks
-----------------------

Holds the definition and current status of each recurring system task.

Suggested schema (SQLite):

  CREATE TABLE system_tasks (
    id                INTEGER PRIMARY KEY,
    name              TEXT NOT NULL,
    task_type         TEXT NOT NULL,
    component         TEXT NOT NULL,
    frequency_cron    TEXT NULL,
    frequency_seconds INTEGER NULL,
    enabled           INTEGER NOT NULL DEFAULT 1,
    last_run_at       DATETIME NULL,
    last_status       TEXT NULL,
    last_result       TEXT NULL,
    error_count       INTEGER NOT NULL DEFAULT 0,
    created_at        DATETIME NOT NULL,
    updated_at        DATETIME NOT NULL,
    UNIQUE (task_type, component)
  );

Field meanings:

- `name`:
  - Human-readable label, e.g. "NewsData Sync", "Calendar Sync".

- `task_type`:
  - Machine-readable identifier for logic, e.g.:
    - "news_sync"
    - "calendar_sync"
    - "alerts_refresh"

- `component`:
  - The owning subsystem; useful for grouping:
    - "news", "calendar", "alerts", "system".

- `frequency_cron`:
  - Optional cron-like expression string ("0 * * * *") for more complex schedules.
  - If null, the engine uses `frequency_seconds`.

- `frequency_seconds`:
  - Interval-based schedule in seconds, e.g.:
    - 2700 (45 minutes) for news sync.
    - 1800 (30 minutes) for calendar sync.

- `enabled`:
  - 1 = active and scheduled.
  - 0 = disabled; engine should skip scheduling this task.

- `last_run_at`:
  - Last time the task was executed (success or failure).

- `last_status`:
  - "success", "error", "skipped", etc.

- `last_result`:
  - Short JSON/text summary, e.g.:
    - "{\"inserted\": 24, \"updated\": 6}"
    - "{\"reason\": \"no api key\"}"

- `error_count`:
  - Consecutive or total error counter (implementation choice).
  - Can be used to show warnings in UI if a task repeatedly fails.

- `created_at`, `updated_at`:
  - Standard timestamps.


2.2 Table: system_task_runs (optional)
--------------------------------------

Optional history of individual task runs.

  CREATE TABLE system_task_runs (
    id            INTEGER PRIMARY KEY,
    task_id       INTEGER NOT NULL REFERENCES system_tasks(id),
    started_at    DATETIME NOT NULL,
    finished_at   DATETIME NULL,
    status        TEXT NOT NULL,
    result        TEXT NULL,
    error_message TEXT NULL
  );

Use cases:

- Debugging: “why isn’t my news syncing?”
- UI: detailed history in an “Advanced” section.
- Observability: show recent successes/failures.

This can be implemented later; scheduler design should not depend on it.


=========================================
3. RUST SCHEDULER ENGINE
=========================================

3.1 Task model structs
----------------------

In Rust, mirror the DB structure with a `SystemTask` struct:

  struct SystemTask {
      id: i64,
      name: String,
      task_type: String,
      component: String,
      frequency_cron: Option<String>,
      frequency_seconds: Option<i64>,
      enabled: bool,
      last_run_at: Option<chrono::DateTime<chrono::Utc>>,
      last_status: Option<String>,
      last_result: Option<String>,
      error_count: i64,
      created_at: chrono::DateTime<chrono::Utc>,
      updated_at: chrono::DateTime<chrono::Utc>,
  }

We may also define:

  enum TaskStatus {
      Success,
      Error,
      Skipped,
  }

  enum TaskType {
      NewsSync,
      CalendarSync,
      AlertsRefresh,
      // ...
  }

Mapping `task_type: String` <-> `TaskType` is done via `FromStr` / `Display`.


3.2 Scheduler startup flow
--------------------------

On backend initialization (inside Tauri `setup` or main async block):

1. Load tasks:

   - Query `system_tasks` where `enabled = 1`.
   - For each row, build `SystemTask`.

2. For each `SystemTask`:

   - Calculate the **initial next run time**.
     - If `last_run_at` is null:
       - Run after `frequency_seconds` from now (or a small delay, e.g. 5 seconds).
     - If `last_run_at` exists:
       - `next_run = last_run_at + frequency_seconds`.

   - Spawn a Tokio task:

     - Loop:
       - Sleep until `next_run`.
       - Call `run_task_once(task_type, task_id)`.
       - Re-load the task (in case frequency or enabled flag changed in DB).
       - Recompute `next_run`.
       - If `enabled` became false, break loop.

NOTE: alternatively, we can centralize scheduling in a single manager task that
watches all tasks and sleeps until the next one is due. For simplicity, one-loop-per-task
is acceptable for a small number of tasks.

3. If using cron expressions:

   - When `frequency_cron` is set, parse it with a cron crate (e.g. `cron` or `tokio-cron-scheduler`).
   - For each task, compute `next_run` using the cron schedule instead of fixed seconds.


3.3 Task execution: run_task_once
---------------------------------

`run_task_once` is the core executor:

  async fn run_task_once(task_type: &str, task_id: i64) {
      let now = chrono::Utc::now();
      // Update started_at in system_task_runs (optional)
      // Call appropriate handler based on task_type
      // Update system_tasks.last_run_at, last_status, last_result, error_count
      // Emit Tauri event with result
  }

Handler dispatch:

  match task_type {
      "news_sync" => handle_news_sync_task(task_id).await,
      "calendar_sync" => handle_calendar_sync_task(task_id).await,
      _ => { /* unknown task type: log + mark error */ }
  }

Each handler returns a `TaskRunResult`:

  struct TaskRunResult {
      status: TaskStatus,
      result_json: Option<String>,  // summary e.g. inserted/updated counts
      error_message: Option<String>,
  }

Scheduler updates:

- `last_run_at = now`
- `last_status = "success" | "error" | "skipped"`
- `last_result = result_json`
- `error_count` incremented/reset based on `status`.

Any long-running work (HTTP calls, DB operations) is inside the handler.


3.4 Concurrency and long-running tasks
--------------------------------------

- Handlers should be **idempotent** per invocation where possible.
- If a task takes longer than its interval or next cron slot:
  - Either:
    - Allow overlapping runs (dangerous).
    - Or keep a simple “is_running” flag in memory or in DB and skip if already running.
- For initial implementation:
  - Use a simple in-memory `HashSet<task_id>` of running tasks to prevent overlap.


=========================================
4. TAURI COMMANDS (BACKEND <-> FRONTEND)
=========================================

The frontend interacts with the scheduler via Tauri `#[tauri::command]`s.

4.1 DTO types (TypeScript-like)
-------------------------------

  type SystemTaskDto = {
    id: number;
    name: string;
    taskType: string;
    component: string;
    frequencyCron?: string | null;
    frequencySeconds?: number | null;
    enabled: boolean;
    lastRunAt?: string | null;
    lastStatus?: "success" | "error" | "skipped" | string | null;
    lastResult?: string | null;
    errorCount: number;
  };

  type SystemTaskRunDto = {
    id: number;
    taskId: number;
    startedAt: string;
    finishedAt?: string | null;
    status: string;
    result?: string | null;
    errorMessage?: string | null;
  };

  type RunTaskNowResult = {
    status: "success" | "error" | "skipped";
    result?: string;
    errorMessage?: string;
    finishedAt: string;
  };


4.2 Commands
------------

### `list_system_tasks() -> Vec<SystemTaskDto>`

- Fetches all tasks (optionally only enabled).
- Used to render “System Tasks” panel in the cockpit.

### `get_system_task(id: i64) -> Option<SystemTaskDto>`

- Fetches a single task by id.

### `update_system_task(task_type: String, input: UpdateTaskInput) -> SystemTaskDto`

Input:

  type UpdateTaskInput = {
    enabled?: boolean;
    frequencySeconds?: number | null;
    frequencyCron?: string | null;
    name?: string;
  };

Behavior:

- Find row by `task_type` (and component if needed).
- Apply changes:
  - If `frequencySeconds` is set, clear `frequency_cron`.
  - If `frequencyCron` is set, clear `frequency_seconds`.
- Set `updated_at = NOW()`.
- Persist and return updated DTO.

Scheduler interaction:

- If a task’s frequency or enabled flag is changed, the scheduler loop should
  notice on next iteration when it reloads or via an explicit “reload” signal.
  Implementation options:
  - Periodically re-read the DB inside each loop.
  - Or send a channel message to the scheduler to restart that task loop.

### `run_system_task_now(task_type: String) -> RunTaskNowResult`

Behavior:

- Immediately invokes `run_task_once(task_type, task_id)` asynchronously.
- Should:
  - Check if the task is currently running; if so, return `"skipped"` with reason.
  - Otherwise, run and return the result.

Frontend usage:

- Invoked by “Sync now” buttons (news, calendar, etc) and “Run now” in System Tasks panel.

### `list_system_task_runs(task_type: String, limit: i64) -> Vec<SystemTaskRunDto>`

- Optional.
- Returns recent history rows for a given task for debugging / advanced UI.


=========================================
5. TAURI EVENTS (BACKEND -> FRONTEND)
=========================================

To push updates to the UI in real time, the scheduler emits Tauri events
whenever a task run completes.

5.1 Event name & payload
------------------------

Event name:

- `"system_task_run"`

Payload shape (JSON):

  {
    "taskType": "news_sync",
    "component": "news",
    "status": "success",              // or "error" | "skipped"
    "result": "{\"inserted\": 24}",
    "errorMessage": null,
    "finishedAt": "2025-12-10T18:10:00Z"
  }

Optional extra fields:

- `taskId`
- `lastRunAt` (mirroring DB)
- `lastStatus` / `lastResult` (after update)

5.2 Emitting events from Rust
-----------------------------

Within `run_task_once` after the handler finishes:

  let payload = TaskRunEventPayload { ... };
  app_handle.emit_all("system_task_run", payload)?;

Frontend will subscribe once at startup.


=========================================
6. FRONTEND INTEGRATION (REACT)
=========================================

6.1 Hooks
---------

### `useSystemTasks()`

- Uses React Query to call `list_system_tasks`.
- Returns:

  {
    data: SystemTaskDto[] | undefined;
    isLoading: boolean;
    refetch: () => void;
  }

Used by:

- A dedicated “System Tasks” panel.
- Potential inline displays of specific tasks (e.g. news_sync card footer shows status).

### `useRunTaskNow(taskType: string)`

- Wraps a React Query mutation that calls `run_system_task_now`.
- Exposes:

  {
    run: () => Promise<RunTaskNowResult>;
    isRunning: boolean;
  }

Usage:

- Buttons labeled “Sync now” under News feed / Calendar, etc.

### `useSystemTaskEvents()`

- Subscribes to the `"system_task_run"` event via Tauri’s `listen`.
- When event fires:
  - Optionally:
    - Show a toast.
    - Update React Query caches (`list_system_tasks`, task-specific stats).

Example behavior:

- If `taskType === "news_sync"` and `status === "success"`:
  - Invalidate `useNewsStats` and `useNewsArticles` queries.
  - Show a toast: “News sync completed · 24 new articles.”


6.2 System Tasks panel UI
-------------------------

A cockpit view of all tasks, e.g. `/settings/system-tasks`.

Columns:

- Task
- Component
- Status (with color/label)
- Last Run
- Frequency
- Error Count
- Actions

Actions:

- Toggle enable/disable:
  - Calls `update_system_task` with `enabled` flipped.
- Edit frequency:
  - Small inline editor:
    - “Every [N] minutes” (mapped to `frequency_seconds`).
- Run now:
  - Calls `run_system_task_now`.

Styling:

- Uses `Card`, `Table`, `Button`, `Badge`.
- Status color coding:
  - success: green accent.
  - error: red.
  - skipped: yellow/amber.

6.3 Metric card integration
---------------------------

Specific tasks can be wired into the Dashboard:

- NewsData Sync:
  - “Feed items” metric uses `useNewsStats`.
  - “Sync now” button uses `useRunTaskNow("news_sync")`.
  - Text like:
    - “Last sync 5 min ago · Status: success”.

- Calendar Sync:
  - “Events” metric uses `useCalendarStats`.
  - “Sync now” uses `useRunTaskNow("calendar_sync")`.

Because tasks are defined and tracked centrally, the UI for each subsystem stays simple:
- It only cares about its own stats and uses common primitives for scheduling.


=========================================
7. SAFETY & EDGE CASES
=========================================

7.1 Double execution / overlap
------------------------------

- Maintain an in-memory `running_tasks: Mutex<HashSet<i64>>` in the scheduler.
- Before executing `run_task_once`:
  - If `task_id` is in `running_tasks`, mark as `"skipped"` with reason `"already running"` and return.
  - Otherwise, insert; after execution, remove.

This prevents accidental overlapping runs if:
- A long task is still running when the interval elapses.
- The user clicks “Run now” while the scheduled run is still in progress.

7.2 Disabled tasks
------------------

- If a task’s `enabled` flag is turned off via UI:
  - The next time the scheduler loop reloads the task (or receives a signal), it stops scheduling further runs.
  - “Run now” should be allowed or forbidden based on desired UX (specify in code).

7.3 Error storms
----------------

- If a task repeatedly fails (e.g., misconfigured API key):
  - `error_count` will increase.
  - Frontend can display a warning banner after threshold (e.g., 3 consecutive errors):
    - “News sync failing repeatedly – check your API settings.”

- Optionally, the scheduler can auto-disable a task after N errors to avoid hammering a broken endpoint.

7.4 App restarts
----------------

On app restart, scheduler:

- Reloads `system_tasks`.
- For each enabled task:
  - Computes `next_run` based on:
    - `last_run_at` + frequency.
- If the app was off for a long time:
  - It will run once shortly after startup, then resume normal schedule.


=========================================
8. SUMMARY
=========================================

The cron-job / scheduler system provides:

- A persistent, DB-backed description of all recurring jobs (`system_tasks`).
- A Tokio-based engine that:
  - Loads tasks at startup.
  - Schedules each task according to interval or cron.
  - Executes task handlers and records results.
  - Emits Tauri events on completion.

- A Tauri API for the frontend to:
  - Inspect and modify tasks (list, enable/disable, change frequency).
  - Trigger immediate runs.
  - View basic run history (optional).

- A React integration layer:
  - Hooks for tasks and “run now” mutations.
  - A System Tasks panel for advanced users.
  - Seamless wiring into Dashboard metric cards (Events, Feed items, Ideas, Alerts).

This design keeps scheduling logic firmly in the Rust backend while exposing
enough control and visibility to the Architect Cockpit UI to feel like a true
control room for the system.
